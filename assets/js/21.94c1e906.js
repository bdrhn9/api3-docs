(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{1006:function(e,a,t){"use strict";t.r(a);var n=t(9),o=Object(n.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("TitleSpan",[e._v("Introduction")]),e._v(" "),n("h1",{attrs:{id:"frontmatter-title"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#frontmatter-title"}},[e._v("#")]),e._v(" "+e._s(e.$frontmatter.title))]),e._v(" "),n("VersionWarning"),e._v(" "),n("TocHeader"),e._v(" "),n("TOC",{staticClass:"table-of-contents",attrs:{"include-level":[2,3]}}),e._v(" "),n("p",[e._v("Beacons are first-party Web3 data feeds run by the API data providers\nthemselves, without third-party oracle nodes as middlemen. Beacons allow smart\ncontract developers to connect their Web3 applications to continuously updated\nstreams of off-chain data, such as the latest cryptocurrency, stock and\ncommodities prices. They can power various decentralized applications, such as\nDeFi lending, synthetic assets, stable coins, derivatives, quality assurance,\nNFTs and more. Operated by the marketâ€™s most trusted and reliable data\nproviders, Beacons are a transparent, cost efficient and scalable way for smart\ncontracts to connect to the data that they need.")]),e._v(" "),n("p",[e._v("To achieve a completely transparent and secure design, Beacons are operated\ndirectly by the API provider of the data they serve, without third-party node\noperators used as data relayers. This means that when calling a Beacon for the\nlatest price of an asset, your smart contract receives a value directly from the\nWeb3-enabled API of the source data provider - not a third-party or a network of\nthird party middlemen.")]),e._v(" "),n("p",[e._v("The provider-operated nature of Beacons allows any dApp to consider the\noff-chain reputation of the data provider and their suitability for any use\ncase. Bringing this level of transparency to the source of data in smart\ncontracts gives dApp developers confidence rather than relying on a pseudonymous\nselection of third parties.")]),e._v(" "),n("h2",{attrs:{id:"simple-implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#simple-implementation"}},[e._v("#")]),e._v(" Simple Implementation")]),e._v(" "),n("p",[e._v("The Beacon Server contract ("),n("em",[e._v("RrpBeaconServer.sol")]),e._v(") maintains a cache of on-chain\nBeacon values readily available for smart contracts to retrieve instantly as\nillustrated in figure below. A Beacon is updated when a pre-defined tolerance of\nthe Beacon's value is detected. Each Beacon has its own configuration parameters\nthat define when and how it updates. See the\n"),n("RouterLink",{attrs:{to:"/beacon/v0.2/functions/read-beacon.html"}},[e._v("readBeacon()")]),e._v(" function doc and learn how your smart\ncontract can access a Beacon .")],1),e._v(" "),n("blockquote",[n("p",[n("img",{attrs:{src:t(600),alt:"dapp-beacon.png"}})])]),e._v(" "),n("h2",{attrs:{id:"airnode-enabled"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#airnode-enabled"}},[e._v("#")]),e._v(" Airnode Enabled")]),e._v(" "),n("p",[e._v("Making it all work is a simple and efficient system that leverages first-party\nAirnodes to keep individual Beacon values up-to-date. When a Beacon's value\nfalls outside a pre-defined tolerance it self-updates by calling its associated\nAirnode.")]),e._v(" "),n("p",[e._v("In the figure below, on-chain Beacons request updates from their linked\noff-chain Airnode. The Airnode's owner (an API provider) configures the\npre-defined tolerance of a Beacon's value as well as the frequency to check for\ntolerance deviation. The Beacon's value is updated when the off-chain value\nfalls outside the Beacons value's defined tolerance. Note that a Airnode can be\nrelated to more than one Beacon.")]),e._v(" "),n("blockquote",[n("p",[n("img",{attrs:{src:t(601),alt:"beacon-airnode.png"}})])]),e._v(" "),n("h2",{attrs:{id:"dapis-building-on-beacons"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dapis-building-on-beacons"}},[e._v("#")]),e._v(" dAPIs (Building on Beacons)")]),e._v(" "),n("p",[e._v("To further exploit the benefit of Beacons, forthcoming dAPIs will enable dApp\ndevelopers a powerful new tool to quickly acquire aggregated Beacon values\non-chain.")]),e._v(" "),n("p",[e._v("dAPIs, like Beacons, are data feeds built entirely on-chain by aggregating data\nfrom more than one Beacon. Because they are built on top of the Beacon layer\ntheir data is also from first-party API provider "),n("em",[e._v("owned and operated Airnodes")]),e._v(".")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("dAPIs are under development for a pending release.")]),e._v(" "),n("p")]),e._v(" "),n("blockquote",[n("p",[n("img",{attrs:{src:t(602),alt:"beacon-airnode.png"}})]),e._v(" "),n("p",{staticClass:"diagram-line",staticStyle:{color:"gray","margin-top":"6px"}},[e._v("A dApp would call a dAPI, as it would a Beacon, to get an instant\nresponse.")])]),e._v(" "),n("p",[e._v("dAPIs consume data from Beacons in order to provide an aggregate value. For\nexample, in the diagram above there could be a dAPI for the ETH/USD price where\nit fetches different prices from multiple Beacons such as a CoinGecko ETH/USD\nbeacon value, a Binance ETH/USD beacon value and so on. Such an dAPI would\naggregate and provide a value for the ETH/USD pair. This is just one use case\nfor a dAPI from endless possibilities.")])],1)}),[],!1,null,null,null);a.default=o.exports},600:function(e,a,t){e.exports=t.p+"assets/img/dapp-beacon.130995f5.png"},601:function(e,a,t){e.exports=t.p+"assets/img/beacon-airnode.6a22d945.png"},602:function(e,a,t){e.exports=t.p+"assets/img/dapi-beacons.23bd5396.png"}}]);